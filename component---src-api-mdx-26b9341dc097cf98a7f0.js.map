{"version":3,"sources":["webpack:///../src/api.mdx"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"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","file":"component---src-api-mdx-26b9341dc097cf98a7f0.js","sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/Users/wendellhu/Developer/Repos/wedi/doc/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    {\n      /* I need a API generator... */\n    }\n    <h1 {...{\n      \"id\": \"api\"\n    }}>{`API`}</h1>\n    <h2 {...{\n      \"id\": \"core\"\n    }}>{`Core`}</h2>\n    <h3 {...{\n      \"id\": \"injector\"\n    }}>{`Injector`}</h3>\n    <p>{`Instantiate, manage, provide and destroy dependencies.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`export declare class Injector implements Disposable {\n  constructor(collection: DependencyCollection, parent?: Injector)\n  add<T>(ctor: Ctor<T>): void\n  add<T>(key: Identifier<T>, item: DependencyValue<T>): void\n  createChild(dependencies?: DependencyCollection): Injector\n  get<T>(id: DependencyKey<T>): T | null\n  getOrInit<T>(id: DependencyKey<T>): T | null\n  createInstance<T>(ctor: Ctor<T> | InitPromise<T>, ...extraParams: any[]): T\n}\n`}</code></pre>\n    <h4 {...{\n      \"id\": \"constructor\"\n    }}>{`Constructor`}</h4>\n    <p>{`Create an injector. Could use the `}<inlineCode parentName=\"p\">{`parent`}</inlineCode>{` parameter to build layered injector system.`}</p>\n    <h4 {...{\n      \"id\": \"methods\"\n    }}>{`Methods`}</h4>\n    <ul>\n      <li parentName=\"ul\"><inlineCode parentName=\"li\">{`add`}</inlineCode>{`, to add a new dependency.`}</li>\n      <li parentName=\"ul\"><inlineCode parentName=\"li\">{`createChild`}</inlineCode>{`, to create a child injector with a bunch of dependencies.`}</li>\n      <li parentName=\"ul\"><inlineCode parentName=\"li\">{`get`}</inlineCode>{`, get a dependency. Return null if there's no existing dependency matching the given `}<inlineCode parentName=\"li\">{`DependencyKey`}</inlineCode>{`.`}</li>\n      <li parentName=\"ul\"><inlineCode parentName=\"li\">{`getOrInit`}</inlineCode>{`, get a dependency, try to instantiate one if there's no existing dependency matching the given `}<inlineCode parentName=\"li\">{`DependencyKey`}</inlineCode></li>\n      <li parentName=\"ul\"><inlineCode parentName=\"li\">{`createInstance`}</inlineCode>{`, instantiate a class. If the class requires dependencies, the injector would provide them.`}</li>\n    </ul>\n    <h3 {...{\n      \"id\": \"dependencycollection\"\n    }}>{`DependencyCollection`}</h3>\n    <p>{`Hold dependencies and manage lifecycle of them.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`export declare class DependencyCollection implements Disposable {\n  constructor(deps?: DependencyItem<any>[])\n  add<T>(ctor: Ctor<T>): void\n  add<T>(key: DependencyKey<T>, item: DependencyValue<T> | T): void\n  has(key: DependencyKey<any>): boolean\n  get<T>(key: DependencyKey<T>): T | DependencyValue<T> | undefined\n}\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"type-dependencyitem\"\n    }}>{`[type]`}{` `}<inlineCode parentName=\"h3\">{`DependencyItem`}</inlineCode></h3>\n    <p>{`Here's valid types of a dependency item.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-tsx\"\n      }}>{`export declare type DependencyValue<T> =\n  | Ctor<T>\n  | ValueItem<T>\n  | ClassItem<T>\n  | FactoryItem<T>\n\nexport declare type DependencyKey<T> = Identifier<T> | Ctor<T>\n\nexport declare type DependencyItem<T> =\n  | [Identifier<T>, DependencyValue<T>]\n  | Ctor<T>\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"createidentifier\"\n    }}><inlineCode parentName=\"h3\">{`createIdentifier`}</inlineCode></h3>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-tsx\"\n      }}>{`export declare function createIdentifier<T>(name: string): Identifier<T>\n`}</code></pre>\n    <p>{`Create an identifier. This identifier could also be used as a decorator to parameters of a class.`}</p>\n    <h3 {...{\n      \"id\": \"decorator-optional\"\n    }}>{`[decorator]`}{` Optional`}</h3>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-tsx\"\n      }}>{`export declare function Optional<T>(\n  key: DependencyKey<T>\n): (target: Ctor<T>, _key: string, index: number) => void\n`}</code></pre>\n    <p>{`This decorator could be applied to parameters of a class to mark its dependencies as `}<strong parentName=\"p\">{`optional`}</strong>{`.`}</p>\n    <h3 {...{\n      \"id\": \"decorator-need\"\n    }}>{`[decorator]`}{` Need`}</h3>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-tsx\"\n      }}>{`export declare function Need<T>(\n  key: DependencyKey<T>\n): <C>(target: Ctor<C>, _key: string, index: number) => void\n`}</code></pre>\n    <p>{`This decorator could be applied to parameters of a class to mark its dependencies as `}<strong parentName=\"p\">{`required`}</strong>{`.`}</p>\n    <h3 {...{\n      \"id\": \"registersingleton\"\n    }}>{`registerSingleton`}</h3>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-tsx\"\n      }}>{`export declare function registerSingleton<T>(\n  id: Identifier<T>,\n  ctor: Ctor<T>,\n  lazyInstantiation?: boolean\n): void\n`}</code></pre>\n    <p>{`Register a class dependency item as singleton with a identifier.`}</p>\n    <h2 {...{\n      \"id\": \"react\"\n    }}>{`React`}</h2>\n    <h3 {...{\n      \"id\": \"provider\"\n    }}><inlineCode parentName=\"h3\">{`Provider`}</inlineCode></h3>\n    <p>{`Create a injection layer in your React application.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-tsx\"\n      }}>{`export declare class Provider extends Component<InjectionProviderProps>;\n\nexport interface InjectionProviderProps {\n    collection?: DependencyCollection;\n    injector?: Injector;\n}\n`}</code></pre>\n    <p><inlineCode parentName=\"p\">{`collection`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`injector`}</inlineCode>{` cannot be both `}<inlineCode parentName=\"p\">{`undefined`}</inlineCode>{`.`}</p>\n    <h3 {...{\n      \"id\": \"provide\"\n    }}>{`Provide`}</h3>\n    <p>{`An decorator that could be used on a React class component to provide a injection context on that component.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-tsx\"\n      }}>{`export declare function Provide(\n  items: DependencyItem<any>[]\n): (target: any) => any\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"inject\"\n    }}><inlineCode parentName=\"h3\">{`Inject`}</inlineCode></h3>\n    <p>{`Returns decorator that could be used on a property of a React class component to inject a dependency`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-tsx\"\n      }}>{`export declare function Inject<T>(\n  id: Identifier<T> | Ctor<T>,\n  optional?: boolean\n): (target: any, propName: string, _originDescriptor?: any) => any\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"usecollection\"\n    }}><inlineCode parentName=\"h3\">{`useCollection`}</inlineCode></h3>\n    <p>{`When providing dependencies in a functional component, it would be expensive (not to mention logic incorrectness) to recreate dependencies.`}</p>\n    <p>{`This API is actually a memo to return the same `}<inlineCode parentName=\"p\">{`DependencyCollection`}</inlineCode>{` in a component.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-tsx\"\n      }}>{`export declare function useCollection(\n  entries?: DependencyItem<any>[]\n): DependencyCollection\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"usedependency\"\n    }}><inlineCode parentName=\"h3\">{`useDependency`}</inlineCode></h3>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-tsx\"\n      }}>{`export declare function useDependency<T>(\n  key: DependencyKey<T>,\n  optional?: boolean\n): T | null\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"rxjs\"\n    }}>{`RxJS`}</h2>\n    <h3 {...{\n      \"id\": \"usedependencyvalue\"\n    }}><inlineCode parentName=\"h3\">{`useDependencyValue`}</inlineCode></h3>\n    <p>{`Unwrap an observable value, return it to the component for rendering, and trigger re-render when value changes`}</p>\n    <p><strong parentName=\"p\">{`IMPORTANT`}</strong>{`. Parent and child components should not subscribe to the same observable, otherwise unnecessary re-render would be triggered. Instead, the top-most component should subscribe and pass value of the observable to its offspring, by props or context.`}</p>\n    <p>{`If you have to do that, consider using `}<inlineCode parentName=\"p\">{`useDependencyContext`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`useDependencyContextValue`}</inlineCode>{` instead.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-tsx\"\n      }}>{`export declare function useDependencyValue<T>(\n  depValue$: Observable<T>,\n  defaultValue?: T\n): T | undefined\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"usedependencycontext--usedependencycontextvalue\"\n    }}><inlineCode parentName=\"h3\">{`useDependencyContext`}</inlineCode>{` & `}<inlineCode parentName=\"h3\">{`useDependencyContextValue`}</inlineCode></h3>\n    <p>{`Subscribe to an observable value from a service, creating a context for it so its child component won't have to subscribe again and cause unnecessary.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-tsx\"\n      }}>{`export declare function useDependencyContext<T>(\n  depValue$: Observable<T>,\n  defaultValue?: T\n): {\n  Provider: (props: {\n    initialState?: T | undefined\n    children: React.ReactNode\n  }) => JSX.Element\n  value: T | undefined\n}\n\nexport declare function useDependencyContextValue<T>(\n  depValue$: Observable<T>\n): T | undefined\n`}</code></pre>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}