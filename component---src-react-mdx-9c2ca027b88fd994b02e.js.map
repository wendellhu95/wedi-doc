{"version":3,"sources":["webpack:///../src/react.mdx"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"2OAMaA,G,UAAe,S,+LAC5B,IAAMC,EAAc,CAClBD,gBAEIE,EAAYC,IACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,EACF,8BACD,OAAO,YAACJ,EAAD,eAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAG5E,iBAAQ,CACN,GAAM,SADR,SAGA,kGACA,iBAAQ,CACN,GAAM,+BADR,+BAGA,4BAAW,0BAAYC,WAAW,KAAvB,WAAX,wFACA,uBAAK,gCAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,8WAcL,iBAAQ,CACN,GAAM,+BADR,+BAGA,uGAAsF,0BAAYA,WAAW,KAAvB,eAAtF,UAAwJ,0BAAYA,WAAW,KAAvB,oBAAxJ,mCAAwP,0BAAYA,WAAW,KAAvB,UAAxP,eACA,uBAAK,gCAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,kSAWL,gFACA,uBAAK,gCAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,gZAeL,qCAAoB,0BAAYA,WAAW,KAAvB,QAApB,+BAAoG,0BAAYA,WAAW,KAAvB,UAApG,+CACA,uBAAK,gCAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,wLAQL,iBAAQ,CACN,GAAM,oCADR,oCAGA,qBAAG,0BAAYA,WAAW,KAAvB,iBAAH,QAAqE,0BAAYA,WAAW,KAAvB,kBAArE,0IACA,uBAAK,gCAAMA,WAAW,OAAU,CAC5B,UAAa,iBADZ,6QAcL,sJACA,uBAAK,gCAAMA,WAAW,OAAU,CAC5B,UAAa,iBADZ,6VAmBL,iHACA,6GAA4F,sBAAQA,WAAW,KAAnB,WAA5F,kFACA,iBAAQ,CACN,GAAM,oCADR,oCAGA,qBAAG,0BAAYA,WAAW,KAAvB,iBAAH,8EAA2I,0BAAYA,WAAW,KAAvB,QAA3I,iDACA,uBAAK,gCAAMA,WAAW,OAAU,CAC5B,UAAa,iBADZ,uVAeL,uGAAsF,0BAAYA,WAAW,KAAvB,mBAAtF,2BACA,uBAAK,gCAAMA,WAAW,OAAU,CAC5B,UAAa,iBADZ,yZAgBL,iBAAQ,CACN,GAAM,iCADR,iCAGA,mMACA,uBAAK,gCAAMA,WAAW,OAAU,CAC5B,UAAa,iBADZ,8iBA8BL,iBAAQ,CACN,GAAM,0BADR,0BAGA,+EACA,uBAAK,gCAAMA,WAAW,OAAU,CAC5B,UAAa,iBADZ,kmB,6LA6BTJ,EAAWK,gBAAiB","file":"component---src-react-mdx-9c2ca027b88fd994b02e.js","sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/Users/wendellhu/Developer/Repos/wedi/doc/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"react\"\n    }}>{`React`}</h1>\n    <p>{`wedi provides API let you use dependency injection in React conveniently.`}</p>\n    <h2 {...{\n      \"id\": \"class-component-as-provider\"\n    }}>{`Class Component as Provider`}</h2>\n    <p>{`The `}<inlineCode parentName=\"p\">{`Provide`}</inlineCode>{` decorator could inject items into the decorated component and its child components.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`import { Provide } from 'wedi';\nimport { FileService } from 'services/file';\nimport { IPlatformService } from 'services/platform';\n\n@Provide([\n  FileService,\n  [IPlatformService, { useClass: MobilePlatformService } ];\n])\nclass ClassComponent extends Component {\n  // FileService and IPlatformService is accessible in the component and its children\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"class-component-as-consumer\"\n    }}>{`Class Component as Consumer`}</h2>\n    <p>{`If you would like consume dependencies in a class component, you should assign `}<inlineCode parentName=\"p\">{`contextType`}</inlineCode>{` to be `}<inlineCode parentName=\"p\">{`InjectionContext`}</inlineCode>{` and get dependencies using the `}<inlineCode parentName=\"p\">{`Inject`}</inlineCode>{` decorator.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`import { Inject, InjectionContext } from 'wedi'\nimport { IPlatformService } from 'services/platform'\n\nclass ClassConsumer extends Component {\n  static contextType = InjectionContext\n\n  @Inject(FileService) fileService!: FileService // accessible to all methods of this class\n}\n`}</code></pre>\n    <p>{`A class component can consume items provided by itself.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`import { Inject, InjectionContext, Provide } from 'wedi';\nimport { IPlatformService } from 'services/platform';\n\n@Provide([\n  FileService,\n  [IPlatformService, { useClass: MobilePlatformService }];\n])\nclass ClassComponent extends Component {\n  static contextType = InjectionContext;\n\n  @Inject(IPlatformService) platformService!: IPlatformService; // this is MobilePlatformService\n}\n`}</code></pre>\n    <p>{`You can pass `}<inlineCode parentName=\"p\">{`true`}</inlineCode>{` as the second parameter of `}<inlineCode parentName=\"p\">{`Inject`}</inlineCode>{` to indicate that a dependency is optional.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`class ClassComponent extends Component {\n  static contextType = InjectionContext\n\n  @Inject(CanBeNullService, true) canBeNullService?: CanBeNullService // this can be null\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"functional-component-as-provider\"\n    }}>{`Functional Component as Provider`}</h2>\n    <p><inlineCode parentName=\"p\">{`useCollection`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`InjectionLayer`}</inlineCode>{` could make functional components as providers and make sure that dependencies wouldn't get re-instantiated when components re-render.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-tsx\"\n      }}>{`import { useCollection, Provider } from 'wedi'\n\nfunction FunctionProvider() {\n  const collection = useCollection([FileService])\n\n  return (\n    <Provider collection={collection}>\n      {/* Child components can use FileService. */}\n    </Provider>\n  )\n}\n`}</code></pre>\n    <p>{`You could also use injectors directly. But this is only recommended when the injector is outside of the React component tree.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-tsx\"\n      }}>{`const injectorFromAnOtherPartOfYourProgram = getInjector()\n\nfunction YourReactRoot(props: { injector: Injector }) {\n  return (\n    <Provider injector={props.injector}>\n      <App />\n    </Provider>\n  )\n}\n\nReactDOM.render(\n  <YourReactRoot\n    injector={injectorFromAnotherPartOfYourProgram}\n  ></YourReactRoot>,\n  containerEl\n)\n`}</code></pre>\n    <p>{`In this way, you could easily integrate React with other part of you application easily.`}</p>\n    <p>{`You can see that when a component tries to get a dependency, it would always ask the `}<strong parentName=\"p\">{`nearest`}</strong>{` provider for it, which means you could use scoped state management with wedi.`}</p>\n    <h2 {...{\n      \"id\": \"functional-component-as-consumer\"\n    }}>{`Functional Component as Consumer`}</h2>\n    <p><inlineCode parentName=\"p\">{`useDependency`}</inlineCode>{` can help you to hook in dependencies. You can assign the second parameter `}<inlineCode parentName=\"p\">{`true`}</inlineCode>{` to mark the injected dependency as optional.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-tsx\"\n      }}>{`import { useDependency } from 'wedi'\nimport { FileService } from 'services/file'\nimport { LogService } from 'services/log'\n\nfunction FunctionConsumer() {\n  const fileService: FileService = useDependency(FileService)\n  const log: LogService | null = useDependency(LogService, true)\n\n  return {\n    /* use dependencies */\n  }\n}\n`}</code></pre>\n    <p>{`Note that functional cannot consume items provided by itself. By you could use `}<inlineCode parentName=\"p\">{`connectProvider`}</inlineCode>{` to make things easier.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-tsx\"\n      }}>{`import { FileService } from 'services/file'\nimport { LogService } from 'services/log'\n\nconst FunctionConsumer = connectProvider((function() {\n  const fileService: FileService = useDependency(FileService)\n  const log: LogService | null = useDependency(LogService, true)\n\n  return {\n    /* use dependencies */\n  }), {\n    collection: new DependencyCollection([FileService, LogService])\n  })\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"multi-layered-injector-system\"\n    }}>{`Multi-Layered Injector System`}</h2>\n    <p>{`injectors of wedi could have child components and React components could have child components. Combined, you could use multi-layered injector system in React seamlessly.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-tsx\"\n      }}>{`@Provide([\n  [IConfig, { useValue: 'A' }],\n  [IConfigRoot, { useValue: 'inRoot' }]\n])\nclass ParentProvider extends Component {\n  render() {\n    return <ChildProvider></ChildProvider>\n  }\n}\n\n@Provide([[IConfig, { useValue: 'B' }]])\nclass ChildProvider extends Component {\n  render() {\n    return <Consumer></Consumer>\n  }\n}\n\nfunction Consumer() {\n  const config = useDependency(IConfig)\n  const rootConfig = useDependency(IConfigRoot)\n\n  return (\n    <div>\n      {config}, {rootConfig}\n    </div> // <div>B, inRoot</div>\n  )\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"inject-react-component\"\n    }}>{`Inject React Component`}</h2>\n    <p>{`You could inject React Component as a dependency, too.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-tsx\"\n      }}>{`const IDropdown = createIdentifier<any>('dropdown')\nconst IConfig = createIdentifier<any>('config')\n\nconst WebDropdown = function() {\n  const dep = useDependency(IConfig) // could use dependencies in its host environment\n  return <div>WeDropdown, {dep}</div>\n}\n\n@Provide([\n  [IDropdown, { useValue: WebDropdown }],\n  [IConfig, { useValue: 'wedi' }]\n])\nclass Header extends Component {\n  static contextType = InjectionContext\n\n  @Inject(IDropdown) private dropdown: any\n\n  render() {\n    const Dropdown = this.dropdown\n    return <Dropdown></Dropdown> // WeDropdown, wedi\n  }\n}\n`}</code></pre>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}