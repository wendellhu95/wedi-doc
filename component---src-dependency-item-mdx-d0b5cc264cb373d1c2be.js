(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{"AD/O":function(e,n,t){"use strict";t.r(n),t.d(n,"_frontmatter",(function(){return l})),t.d(n,"default",(function(){return s}));var a=t("Fcif"),i=t("+I+c"),c=t("/FXl"),r=t("TjRS"),l=(t("aD51"),{});void 0!==l&&l&&l===Object(l)&&Object.isExtensible(l)&&!l.hasOwnProperty("__filemeta")&&Object.defineProperty(l,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"src/dependency-item.mdx"}});var o={_frontmatter:l},p=r.a;function s(e){var n=e.components,t=Object(i.a)(e,["components"]);return Object(c.b)(p,Object(a.a)({},o,t,{components:n,mdxType:"MDXLayout"}),Object(c.b)("h1",{id:"dependency-item"},"Dependency Item"),Object(c.b)("p",null,"wedi supports different kinds of dependency items, including"),Object(c.b)("ul",null,Object(c.b)("li",{parentName:"ul"},"classes"),Object(c.b)("li",{parentName:"ul"},"instances and values"),Object(c.b)("li",{parentName:"ul"},"factory functions")),Object(c.b)("h2",{id:"key-of-a-dependency-item"},Object(c.b)("inlineCode",{parentName:"h2"},"key")," of a Dependency Item"),Object(c.b)("p",null,"When you provide a dependency item (type ",Object(c.b)("inlineCode",{parentName:"p"},"DependencyItem"),"), you're actually injecting a pair of ",Object(c.b)("em",{parentName:"p"},"key")," & ",Object(c.b)("em",{parentName:"p"},"value"),". The value is the dependency item, and the ",Object(c.b)("em",{parentName:"p"},"key")," is the identifier of it. Specially, a ES6 class could be the ",Object(c.b)("em",{parentName:"p"},"key")," and the value and the same time."),Object(c.b)("p",null,Object(c.b)("em",{parentName:"p"},"key")," is an identifier returned by calling ",Object(c.b)("inlineCode",{parentName:"p"},"createIdentifier"),"."),Object(c.b)("p",null,"Not that ",Object(c.b)("inlineCode",{parentName:"p"},"key")," or identifier is required when providing values, instances or factory methods but optional when providing classes."),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"import { createIdentifier } from 'wedi'\n\nexport interface IPlatform {\n  // properties\n  // methods\n}\n\nexport const IPlatformService = createIdentifier<IPlatformService>('platform')\n")),Object(c.b)("p",null,Object(c.b)("em",{parentName:"p"},"You can use the same name for a variable and a type in TypeScript.")),Object(c.b)("h2",{id:"class-as-dependency"},"Class as Dependency"),Object(c.b)("p",null,"An ES6 class could be a dependency item."),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"const classDep = [IClass, { useClass: RealClass }]\n")),Object(c.b)("h3",{id:"deprecated-initpromise"},"(deprecated) InitPromise"),Object(c.b)("p",null,Object(c.b)("inlineCode",{parentName:"p"},"InitPromise")," is implementation detail. Please use ",Object(c.b)("inlineCode",{parentName:"p"},"useClass")," instead."),Object(c.b)("h2",{id:"class-as-consumer"},"Class as Consumer"),Object(c.b)("p",null,"You can declare its dependencies in its constructor. wedi would analyze dependency relation among different classes and instantiate them correctly."),Object(c.b)("p",null,"You can use ",Object(c.b)("inlineCode",{parentName:"p"},"Need")," to declare that ",Object(c.b)("inlineCode",{parentName:"p"},"FileService")," depends on ",Object(c.b)("inlineCode",{parentName:"p"},"IPlatformService"),"."),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"class FileService {\n  constructor(@Need(IPlatformService) private logService: IPlatformService) {}\n}\n")),Object(c.b)("p",null,"wedi would get or instantiates a ",Object(c.b)("inlineCode",{parentName:"p"},"IPlatformService")," before it instantiates ",Object(c.b)("inlineCode",{parentName:"p"},"FileService"),". And if it could not instantiate a ",Object(c.b)("inlineCode",{parentName:"p"},"IPlatformService")," it would throw an error."),Object(c.b)("p",null,"And identifiers created by ",Object(c.b)("inlineCode",{parentName:"p"},"createIdentifier")," could also be used to define dependency relationship. It's equivalent to the example above."),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"class SomeService {\n  constructor(@IPlatformService private platform: IPlatformService) {}\n}\n")),Object(c.b)("p",null,"You can also use the ",Object(c.b)("inlineCode",{parentName:"p"},"Optional")," decorator to declare an optional dependency."),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"class FileService {\n  constructor(@Optional(OptionalDependency) private op?: OptionalDependency) {}\n}\n")),Object(c.b)("p",null,"If ",Object(c.b)("inlineCode",{parentName:"p"},"OptionalDependency")," is not provided, wedi would not throw an error but return ",Object(c.b)("inlineCode",{parentName:"p"},"null")," instead to instantiate ",Object(c.b)("inlineCode",{parentName:"p"},"FileService"),"."),Object(c.b)("h2",{id:"value-or-instance-as-dependency"},"Value or Instance as Dependency"),Object(c.b)("p",null,"It's easy to provide a value as dependency."),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"const configDep = [IConfig, { useValue: '2020' }]\n")),Object(c.b)("h2",{id:"factory-function-as-dependency"},"Factory Function as Dependency"),Object(c.b)("p",null,"You can create a dependency via ",Object(c.b)("inlineCode",{parentName:"p"},"useFactory")," that gives the control flow back to you on initializing."),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"const useDep = [IUserService, {\n  useFactory: (http: IHTTPService): IUserService => new TimeSerialUserService(http, TIME)ï¼Œ\n  deps: [IHTTPService] // this factory depends on IHTTPService.\n}]\n")),Object(c.b)("h2",{id:"provide-items"},"Provide Items"),Object(c.b)("p",null,"Finally, you should wrap all items in an array and pass them to the constructor of ",Object(c.b)("inlineCode",{parentName:"p"},"DependencyCollection"),"."),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"const dependencies = [\n  LogService,\n  FileService,\n  [IConfig, { useValue: '2020' }],\n  [\n    IUserService,\n    {\n      useFactory: (http: IHTTPService): IUserService =>\n        new TimeSerialUserService(http, TIME),\n      deps: [IHTTPService]\n    }\n  ],\n  [IHTTPService, WebHTTPService]\n]\n")),Object(c.b)("h2",{id:"singleton-dependency"},"Singleton Dependency"),Object(c.b)("p",null,"For dependencies that should be singleton in the application, it's recommended to use ",Object(c.b)("inlineCode",{parentName:"p"},"registerSingleton"),"."),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"registerSingleton(/* a dependency item */)\n")),Object(c.b)("p",null,"Dependencies would be provided by the root provider. In another word, the provider which is constructed without a ",Object(c.b)("inlineCode",{parentName:"p"},"parent")," parameter."),Object(c.b)("h2",{id:"lazy-instantiation"},"Lazy Instantiation"),Object(c.b)("p",null,"When you provide class as dependency item, you can make in lazy-instantiated:"),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"const layDep = [ISomeToken, { useClass: LazyClass, lazyInstantiation: true }]\n")),Object(c.b)("p",null,"Lazy dependency will be initiated when its properties or methods are actually used."))}void 0!==s&&s&&s===Object(s)&&Object.isExtensible(s)&&!s.hasOwnProperty("__filemeta")&&Object.defineProperty(s,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"src/dependency-item.mdx"}}),s.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-dependency-item-mdx-d0b5cc264cb373d1c2be.js.map