(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{"AD/O":function(e,n,t){"use strict";t.r(n),t.d(n,"_frontmatter",(function(){return c})),t.d(n,"default",(function(){return p}));t("5hJT"),t("W1QL"),t("K/PF"),t("t91x"),t("75LO"),t("PJhk");var a=t("/FXl"),i=t("TjRS");t("aD51");function r(){return(r=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e}).apply(this,arguments)}var c={};void 0!==c&&c&&c===Object(c)&&Object.isExtensible(c)&&!c.hasOwnProperty("__filemeta")&&Object.defineProperty(c,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"src/dependency-item.mdx"}});var o={_frontmatter:c},l=i.a;function p(e){var n=e.components,t=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,["components"]);return Object(a.b)(l,r({},o,t,{components:n,mdxType:"MDXLayout"}),Object(a.b)("h1",{id:"dependency-item"},"Dependency Item"),Object(a.b)("p",null,"wedi supports different kinds of dependency items, including"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"classes"),Object(a.b)("li",{parentName:"ul"},"instances and values"),Object(a.b)("li",{parentName:"ul"},"factory functions")),Object(a.b)("h2",{id:"key-of-a-dependency-item"},Object(a.b)("inlineCode",{parentName:"h2"},"key")," of a Dependency Item"),Object(a.b)("p",null,"When you provide a dependency item (type ",Object(a.b)("inlineCode",{parentName:"p"},"DependencyItem"),"), you're actually injecting a pair of ",Object(a.b)("em",{parentName:"p"},"key")," & ",Object(a.b)("em",{parentName:"p"},"value"),". The value is the dependency item, and the ",Object(a.b)("em",{parentName:"p"},"key")," is the identifier of it. Specially, a ES6 class could be the ",Object(a.b)("em",{parentName:"p"},"key")," and the value and the same time."),Object(a.b)("p",null,Object(a.b)("em",{parentName:"p"},"key")," is an identifier returned by calling ",Object(a.b)("inlineCode",{parentName:"p"},"createIdentifier"),"."),Object(a.b)("p",null,"Not that ",Object(a.b)("inlineCode",{parentName:"p"},"key")," or identifier is required when providing values, instances or factory methods but optional when providing classes."),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-ts"}),"import { createIdentifier } from 'wedi'\n\nexport interface IPlatform {\n  // properties\n  // methods\n}\n\nexport const IPlatformService = createIdentifier<IPlatformService>('platform')\n")),Object(a.b)("p",null,Object(a.b)("em",{parentName:"p"},"You can use the same name for a variable and a type in TypeScript.")),Object(a.b)("h2",{id:"class-as-dependency"},"Class as Dependency"),Object(a.b)("p",null,"An ES6 class could be a dependency item. You can declare its dependencies in its constructor. wedi would analyze dependency relation among different classes and instantiate them correctly."),Object(a.b)("p",null,"You can use ",Object(a.b)("inlineCode",{parentName:"p"},"Need")," to declare that ",Object(a.b)("inlineCode",{parentName:"p"},"FileService")," depends on ",Object(a.b)("inlineCode",{parentName:"p"},"IPlatformService"),"."),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-ts"}),"class FileService {\n  constructor(@Need(IPlatformService) private logService: IPlatformService) {}\n}\n")),Object(a.b)("p",null,"wedi would get or instantiates a ",Object(a.b)("inlineCode",{parentName:"p"},"IPlatformService")," before it instantiates ",Object(a.b)("inlineCode",{parentName:"p"},"FileService"),". And if it could not instantiate a ",Object(a.b)("inlineCode",{parentName:"p"},"IPlatformService")," it would throw an error."),Object(a.b)("p",null,"And identifiers created by ",Object(a.b)("inlineCode",{parentName:"p"},"createIdentifier")," could also be used to define dependency relationship. It's equivalent to the example above."),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-ts"}),"class SomeService {\n  constructor(@IPlatformService private platform: IPlatformService) {}\n}\n")),Object(a.b)("p",null,"You can also use the ",Object(a.b)("inlineCode",{parentName:"p"},"Optional")," decorator to declare an optional dependency."),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-ts"}),"class FileService {\n  constructor(@Optional(OptionalDependency) private op?: OptionalDependency) {}\n}\n")),Object(a.b)("p",null,"If ",Object(a.b)("inlineCode",{parentName:"p"},"OptionalDependency")," is not provided, wedi would not throw an error but return ",Object(a.b)("inlineCode",{parentName:"p"},"null")," instead to instantiate ",Object(a.b)("inlineCode",{parentName:"p"},"FileService"),"."),Object(a.b)("h2",{id:"value-or-instance-as-dependency"},"Value or Instance as Dependency"),Object(a.b)("p",null,"It's easy to provide a value as dependency."),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-ts"}),"const configDep = [IConfig, { useValue: '2020' }]\n")),Object(a.b)("h2",{id:"factory-function-as-dependency"},"Factory Function as Dependency"),Object(a.b)("p",null,"You can create a dependency via ",Object(a.b)("inlineCode",{parentName:"p"},"useFactory")," that gives the control flow back to you on initializing."),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-ts"}),"const useDep = [IUserService, {\n  useFactory: (http: IHTTPService): IUserService => new TimeSerialUserService(http, TIME)ï¼Œ\n  deps: [IHTTPService] // this factory depends on IHTTPService.\n}]\n")),Object(a.b)("h2",{id:"provide-items"},"Provide Items"),Object(a.b)("p",null,"Finally, you should wrap all items in an array and pass them to the constructor of ",Object(a.b)("inlineCode",{parentName:"p"},"DependencyCollection"),"."),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-ts"}),"const dependencies = [\n  LogService,\n  FileService,\n  [IConfig, { useValue: '2020' }],\n  [\n    IUserService,\n    {\n      useFactory: (http: IHTTPService): IUserService =>\n        new TimeSerialUserService(http, TIME),\n      deps: [IHTTPService]\n    }\n  ],\n  [IHTTPService, WebHTTPService]\n]\n")),Object(a.b)("h2",{id:"singleton-dependency"},"Singleton Dependency"),Object(a.b)("p",null,"For dependencies that should be singleton in the application, it's recommended to use ",Object(a.b)("inlineCode",{parentName:"p"},"registerSingleton"),"."),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-ts"}),"registerSingleton(/* a dependency item */)\n")),Object(a.b)("p",null,"Dependencies would be provided by the root provider. In another word, the provider which is constructed without a ",Object(a.b)("inlineCode",{parentName:"p"},"parent")," parameter."),Object(a.b)("h2",{id:"lazy-instantiation"},"Lazy Instantiation"))}void 0!==p&&p&&p===Object(p)&&Object.isExtensible(p)&&!p.hasOwnProperty("__filemeta")&&Object.defineProperty(p,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"src/dependency-item.mdx"}}),p.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-dependency-item-mdx-f307f19bc2e173334174.js.map