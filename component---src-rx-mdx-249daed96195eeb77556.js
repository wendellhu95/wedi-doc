(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{EvQy:function(e,n,t){"use strict";t.r(n),t.d(n,"_frontmatter",(function(){return r})),t.d(n,"default",(function(){return u}));t("5hJT"),t("W1QL"),t("K/PF"),t("t91x"),t("75LO"),t("PJhk");var i=t("/FXl"),o=t("TjRS");t("aD51");function a(){return(a=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var i in t)Object.prototype.hasOwnProperty.call(t,i)&&(e[i]=t[i])}return e}).apply(this,arguments)}var r={};void 0!==r&&r&&r===Object(r)&&Object.isExtensible(r)&&!r.hasOwnProperty("__filemeta")&&Object.defineProperty(r,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"src/rx.mdx"}});var c={_frontmatter:r},s=o.a;function u(e){var n=e.components,t=function(e,n){if(null==e)return{};var t,i,o={},a=Object.keys(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,["components"]);return Object(i.b)(s,a({},c,t,{components:n,mdxType:"MDXLayout"}),Object(i.b)("h1",{id:"with-rxjs"},"With RxJS"),Object(i.b)("p",null,Object(i.b)("em",{parentName:"p"},"This guide assumes that you have a basic knowledge of RxJS and reactive programming.")),Object(i.b)("p",null,"wedi gives you a clear model for state management and logic reuse. With RxJS, wedi brings reactive programming to your application."),Object(i.b)("h2",{id:"an-example"},"An Example"),Object(i.b)("p",null,"Here is a real-life example. Assuming that we need to fetch latest notifications every 10 seconds after the application bootstraps and the header bar is rendered on the screen. And when the previous request for notification gets delayed, we need to drop it when the current request is sent."),Object(i.b)("p",null,"See the RxJS + wedi version:"),Object(i.b)("pre",null,Object(i.b)("code",a({parentName:"pre"},{className:"language-tsx"}),"class NotificationService implements Disposable {\n  destroy$: Subject<void>()\n  notifications$: Observable<Array<INotification>>\n\n  constructor(\n    @Need(ILifecycleService) lifecycleS: ILifecycleService,\n    @Need(IHttpService) httpS: IHttpService\n  ) {\n    this.destroy = new Subject<void>();\n    this.notificationS = this.lifecycleS.bootstrap$\n      .pipe(\n        take(1),\n        concatMap(() => interval(10000)),\n        concatMap(() => httpS.request(/* some url */)),\n        startWith([]),\n        takeUntil(this.destroy$),\n      )\n  }\n\n  dispose(): void {\n    this.destroy$.next()\n    this.destroy$.complete()\n  }\n}\n\nfunction Header() {\n  const collection = useCollection([NotificationService])\n\n  return <Provider collection={collection}>\n    <DeeplyWrapped>\n      <NotificationDisplayer />\n    </DeeplyWrapper>\n  </Provider>\n}\n\n\nfunction NotificationDisplayer() {\n  const notiS = useDependency(NotificationService)\n  const notifications = useDependencyValue(notiS.notifications$)\n\n  // render notifications\n}\n")),Object(i.b)("p",null,"You can see that the code is concise, declarative, easy to understand and maintain. Logic is completely moved from components to services."),Object(i.b)("p",null,"In fact, you could use any reactive programming library with wedi since it just provide a framework on which you can put observables and subscriptions. But wedi provides Hooks that works with RxJS to make your life easier."),Object(i.b)("h2",{id:"value-context"},"Value Context"),Object(i.b)("p",null,"Sometimes you need to subscribe to the same observable value in a component and its child components. You could use ",Object(i.b)("inlineCode",{parentName:"p"},"useDependencyValue"),". But this would cause unnecessary reconciliation. You could subscribe in the parent component and pass values to the child components, but it would be troublesome if the child component is deeply wrapped. So it's nature to use React Context here. wedi provides ",Object(i.b)("inlineCode",{parentName:"p"},"useDependencyContext")," and ",Object(i.b)("inlineCode",{parentName:"p"},"useDependencyContextValue")," to make this easier."),Object(i.b)("pre",null,Object(i.b)("code",a({parentName:"pre"},{className:"language-tsx"}),"function Parent() {\n  const authS = useDependency(AuthenticationService)\n  const { Provider: AuthProvider } = useDependencyContext(authS.auth$, {})\n\n  return (\n    <AuthProvider>\n      <Child />\n    </AuthProvider>\n  )\n}\n\nfunction Child() {\n  const authS = useDependency(AuthenticationService)\n  const auth = useDependencyContextValue(authS.auth$)\n\n  // adjust UI according to authentication info\n}\n")))}void 0!==u&&u&&u===Object(u)&&Object.isExtensible(u)&&!u.hasOwnProperty("__filemeta")&&Object.defineProperty(u,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"src/rx.mdx"}}),u.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-rx-mdx-249daed96195eeb77556.js.map