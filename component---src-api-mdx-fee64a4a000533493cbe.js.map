{"version":3,"sources":["webpack:///../src/api.mdx"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"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","file":"component---src-api-mdx-fee64a4a000533493cbe.js","sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"D:/Developer/Repos/wedi/doc/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    {\n      /* I need a API generator... */\n    }\n    <h1 {...{\n      \"id\": \"api\"\n    }}>{`API`}</h1>\n    <h2 {...{\n      \"id\": \"core\"\n    }}>{`Core`}</h2>\n    <h3 {...{\n      \"id\": \"injector\"\n    }}>{`Injector`}</h3>\n    <p>{`Instantiate, manage, provide and destroy dependencies.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`export declare class Injector implements Disposable {\n  constructor(collection: DependencyCollection, parent?: Injector)\n  add<T>(ctor: Ctor<T>): void\n  add<T>(key: Identifier<T>, item: DependencyValue<T>): void\n  createChild(dependencies?: DependencyCollection): Injector\n  get<T>(id: DependencyKey<T>): T | null\n  getOrInit<T>(id: DependencyKey<T>): T | null\n  createInstance<T>(ctor: Ctor<T> | InitPromise<T>, ...extraParams: any[]): T\n}\n`}</code></pre>\n    <h4 {...{\n      \"id\": \"constructor\"\n    }}>{`Constructor`}</h4>\n    <p>{`Create an injector. Could use the `}<inlineCode parentName=\"p\">{`parent`}</inlineCode>{` parameter to build layered injector system.`}</p>\n    <h4 {...{\n      \"id\": \"methods\"\n    }}>{`Methods`}</h4>\n    <ul>\n      <li parentName=\"ul\"><inlineCode parentName=\"li\">{`add`}</inlineCode>{`, to add a new dependency.`}</li>\n      <li parentName=\"ul\"><inlineCode parentName=\"li\">{`createChild`}</inlineCode>{`, to create a child injector with a bunch of dependencies.`}</li>\n      <li parentName=\"ul\"><inlineCode parentName=\"li\">{`get`}</inlineCode>{`, get a dependency. Return null if there's no existing dependency matching the given `}<inlineCode parentName=\"li\">{`DependencyKey`}</inlineCode>{`.`}</li>\n      <li parentName=\"ul\"><inlineCode parentName=\"li\">{`getOrInit`}</inlineCode>{`, get a dependency, try to instantiate one if there's no existing dependency matching the given `}<inlineCode parentName=\"li\">{`DependencyKey`}</inlineCode></li>\n      <li parentName=\"ul\"><inlineCode parentName=\"li\">{`createInstance`}</inlineCode>{`, instantiate a class. If the class requires dependencies, the injector would provide them.`}</li>\n    </ul>\n    <h3 {...{\n      \"id\": \"dependencycollection\"\n    }}>{`DependencyCollection`}</h3>\n    <p>{`Hold dependencies and manage lifecycle of them.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`export declare class DependencyCollection implements Disposable {\n    constructor(deps?: DependencyItem<any>[]);\n    add<T>(ctor: Ctor<T>): void;\n    add<T>(key: DependencyKey<T>, item: DependencyValue<T> | T): void;\n    has(key: DependencyKey<any>): boolean;\n    get<T>(key: DependencyKey<T>): T | DependencyValue<T> | undefined;\n}\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"type-dependencyitem\"\n    }}>{`[type]`}{` `}<inlineCode parentName=\"h3\">{`DependencyItem`}</inlineCode></h3>\n    <p>{`Here's valid types of a dependency item.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-tsx\"\n      }}>{`export declare type DependencyValue<T> = Ctor<T> | ValueItem<T> | ClassItem<T> | FactoryItem<T>;\n\nexport declare type DependencyKey<T> = Identifier<T> | Ctor<T>;\n\nexport declare type DependencyItem<T> = [Identifier<T>, DependencyValue<T>] | Ctor<T>;\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"createidentifier\"\n    }}><inlineCode parentName=\"h3\">{`createIdentifier`}</inlineCode></h3>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-tsx\"\n      }}>{`export declare function createIdentifier<T>(name: string): Identifier<T>;\n`}</code></pre>\n    <p>{`Create an identifier. This identifier could also be used as a decorator to parameters of a class.`}</p>\n    <h3 {...{\n      \"id\": \"decorator-optional\"\n    }}>{`[decorator]`}{` Optional`}</h3>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-tsx\"\n      }}>{`export declare function Optional<T>(key: DependencyKey<T>): (target: Ctor<T>, _key: string, index: number) => void;\n`}</code></pre>\n    <p>{`This decorator could be applied to parameters of a class to mark its dependencies as `}<strong parentName=\"p\">{`optional`}</strong>{`.`}</p>\n    <h3 {...{\n      \"id\": \"decorator-need\"\n    }}>{`[decorator]`}{` Need`}</h3>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-tsx\"\n      }}>{`export declare function Need<T>(key: DependencyKey<T>): <C>(target: Ctor<C>, _key: string, index: number) => void;\n`}</code></pre>\n    <p>{`This decorator could be applied to parameters of a class to mark its dependencies as `}<strong parentName=\"p\">{`required`}</strong>{`.`}</p>\n    <h3 {...{\n      \"id\": \"registersingleton\"\n    }}>{`registerSingleton`}</h3>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-tsx\"\n      }}>{`export declare function registerSingleton<T>(id: Identifier<T>, ctor: Ctor<T>, lazyInstantiation?: boolean): void;\n`}</code></pre>\n    <p>{`Register a class dependency item as singleton with a identifier.`}</p>\n    <h2 {...{\n      \"id\": \"react\"\n    }}>{`React`}</h2>\n    <h3 {...{\n      \"id\": \"provider\"\n    }}><inlineCode parentName=\"h3\">{`Provider`}</inlineCode></h3>\n    <p>{`Create a injection layer in your React application.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-tsx\"\n      }}>{`export declare class Provider extends Component<InjectionProviderProps>;\n\nexport interface InjectionProviderProps {\n    collection?: DependencyCollection;\n    injector?: Injector;\n}\n`}</code></pre>\n    <p><inlineCode parentName=\"p\">{`collection`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`injector`}</inlineCode>{` cannot be both `}<inlineCode parentName=\"p\">{`undefined`}</inlineCode>{`.`}</p>\n    <h3 {...{\n      \"id\": \"provide\"\n    }}>{`Provide`}</h3>\n    <p>{`An decorator that could be used on a React class component to provide a injection context on that component.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-tsx\"\n      }}>{`export declare function Provide(items: DependencyItem<any>[]): (target: any) => any;\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"inject\"\n    }}><inlineCode parentName=\"h3\">{`Inject`}</inlineCode></h3>\n    <p>{`Returns decorator that could be used on a property of a React class component to inject a dependency`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-tsx\"\n      }}>{`export declare function Inject<T>(id: Identifier<T> | Ctor<T>, optional?: boolean): (target: any, propName: string, _originDescriptor?: any) => any;\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"usecollection\"\n    }}><inlineCode parentName=\"h3\">{`useCollection`}</inlineCode></h3>\n    <p>{`When providing dependencies in a functional component, it would be expensive (not to mention logic incorrectness) to recreate dependencies.`}</p>\n    <p>{`This API is actually a memo to return the same `}<inlineCode parentName=\"p\">{`DependencyCollection`}</inlineCode>{` in a component.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-tsx\"\n      }}>{`export declare function useCollection(entries?: DependencyItem<any>[]): DependencyCollection;\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"usedependency\"\n    }}><inlineCode parentName=\"h3\">{`useDependency`}</inlineCode></h3>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-tsx\"\n      }}>{`export declare function useDependency<T>(key: DependencyKey<T>, optional?: boolean): T | null;\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"rxjs\"\n    }}>{`RxJS`}</h2>\n    <h3 {...{\n      \"id\": \"usedependencyvalue\"\n    }}><inlineCode parentName=\"h3\">{`useDependencyValue`}</inlineCode></h3>\n    <p>{`Unwrap an observable value, return it to the component for rendering, and trigger re-render when value changes`}</p>\n    <p><strong parentName=\"p\">{`IMPORTANT`}</strong>{`. Parent and child components should not subscribe to the same observable, otherwise unnecessary re-render would be triggered. Instead, the top-most component should subscribe and pass value of the observable to its offspring, by props or context.`}</p>\n    <p>{`If you have to do that, consider using `}<inlineCode parentName=\"p\">{`useDependencyContext`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`useDependencyContextValue`}</inlineCode>{` instead.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-tsx\"\n      }}>{`export declare function useDependencyValue<T>(depValue$: Observable<T>, defaultValue?: T): T | undefined;\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"usedependencycontext--usedependencycontextvalue\"\n    }}><inlineCode parentName=\"h3\">{`useDependencyContext`}</inlineCode>{` & `}<inlineCode parentName=\"h3\">{`useDependencyContextValue`}</inlineCode></h3>\n    <p>{`Subscribe to an observable value from a service, creating a context for it so its child component won't have to subscribe again and cause unnecessary.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-tsx\"\n      }}>{`export declare function useDependencyContext<T>(depValue$: Observable<T>, defaultValue?: T): {\n    Provider: (props: {\n        initialState?: T | undefined;\n        children: React.ReactNode;\n    }) => JSX.Element;\n    value: T | undefined;\n};\n\nexport declare function useDependencyContextValue<T>(depValue$: Observable<T>): T | undefined;\n`}</code></pre>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}