(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{"0VpC":function(e,n,t){"use strict";t.r(n),t.d(n,"_frontmatter",(function(){return i})),t.d(n,"default",(function(){return b}));var a=t("Fcif"),c=t("+I+c"),o=t("/FXl"),r=t("TjRS"),i=(t("aD51"),{});void 0!==i&&i&&i===Object(i)&&Object.isExtensible(i)&&!i.hasOwnProperty("__filemeta")&&Object.defineProperty(i,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"src/api.mdx"}});var l={_frontmatter:i},d=r.a;function b(e){var n=e.components,t=Object(c.a)(e,["components"]);return Object(o.b)(d,Object(a.a)({},l,t,{components:n,mdxType:"MDXLayout"}),Object(o.b)("h1",{id:"api"},"API"),Object(o.b)("h2",{id:"core"},"Core"),Object(o.b)("h3",{id:"injector"},"Injector"),Object(o.b)("p",null,"Instantiate, manage, provide and destroy dependencies."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"export declare class Injector implements Disposable {\n  constructor(collection: DependencyCollection, parent?: Injector)\n  add<T>(ctor: Ctor<T>): void\n  add<T>(key: Identifier<T>, item: DependencyValue<T>): void\n  createChild(dependencies?: DependencyCollection): Injector\n  get<T>(id: DependencyKey<T>): T | null\n  getOrInit<T>(id: DependencyKey<T>): T | null\n  createInstance<T>(ctor: Ctor<T> | InitPromise<T>, ...extraParams: any[]): T\n}\n")),Object(o.b)("h4",{id:"constructor"},"Constructor"),Object(o.b)("p",null,"Create an injector. Could use the ",Object(o.b)("inlineCode",{parentName:"p"},"parent")," parameter to build layered injector system."),Object(o.b)("h4",{id:"methods"},"Methods"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"add"),", to add a new dependency."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"createChild"),", to create a child injector with a bunch of dependencies."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"get"),", get a dependency. Return null if there's no existing dependency matching the given ",Object(o.b)("inlineCode",{parentName:"li"},"DependencyKey"),"."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"getOrInit"),", get a dependency, try to instantiate one if there's no existing dependency matching the given ",Object(o.b)("inlineCode",{parentName:"li"},"DependencyKey")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"createInstance"),", instantiate a class. If the class requires dependencies, the injector would provide them.")),Object(o.b)("h3",{id:"dependencycollection"},"DependencyCollection"),Object(o.b)("p",null,"Hold dependencies and manage lifecycle of them."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"export declare class DependencyCollection implements Disposable {\n  constructor(deps?: DependencyItem<any>[])\n  add<T>(ctor: Ctor<T>): void\n  add<T>(key: DependencyKey<T>, item: DependencyValue<T> | T): void\n  has(key: DependencyKey<any>): boolean\n  get<T>(key: DependencyKey<T>): T | DependencyValue<T> | undefined\n}\n")),Object(o.b)("h3",{id:"type-dependencyitem"},"[type]"," ",Object(o.b)("inlineCode",{parentName:"h3"},"DependencyItem")),Object(o.b)("p",null,"Here's valid types of a dependency item."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),"export declare type DependencyValue<T> =\n  | Ctor<T>\n  | ValueItem<T>\n  | ClassItem<T>\n  | FactoryItem<T>\n\nexport declare type DependencyKey<T> = Identifier<T> | Ctor<T>\n\nexport declare type DependencyItem<T> =\n  | [Identifier<T>, DependencyValue<T>]\n  | Ctor<T>\n")),Object(o.b)("h3",{id:"createidentifier"},Object(o.b)("inlineCode",{parentName:"h3"},"createIdentifier")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),"export declare function createIdentifier<T>(name: string): Identifier<T>\n")),Object(o.b)("p",null,"Create an identifier. This identifier could also be used as a decorator to parameters of a class."),Object(o.b)("h3",{id:"decorator-optional"},"[decorator]"," Optional"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),"export declare function Optional<T>(\n  key: DependencyKey<T>\n): (target: Ctor<T>, _key: string, index: number) => void\n")),Object(o.b)("p",null,"This decorator could be applied to parameters of a class to mark its dependencies as ",Object(o.b)("strong",{parentName:"p"},"optional"),"."),Object(o.b)("h3",{id:"decorator-need"},"[decorator]"," Need"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),"export declare function Need<T>(\n  key: DependencyKey<T>\n): <C>(target: Ctor<C>, _key: string, index: number) => void\n")),Object(o.b)("p",null,"This decorator could be applied to parameters of a class to mark its dependencies as ",Object(o.b)("strong",{parentName:"p"},"required"),"."),Object(o.b)("h3",{id:"registersingleton"},"registerSingleton"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),"export declare function registerSingleton<T>(\n  id: Identifier<T>,\n  ctor: Ctor<T>,\n  lazyInstantiation?: boolean\n): void\n")),Object(o.b)("p",null,"Register a class dependency item as singleton with a identifier."),Object(o.b)("h2",{id:"react"},"React"),Object(o.b)("h3",{id:"provider"},Object(o.b)("inlineCode",{parentName:"h3"},"Provider")),Object(o.b)("p",null,"Create a injection layer in your React application."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),"export declare class Provider extends Component<InjectionProviderProps>;\n\nexport interface InjectionProviderProps {\n    collection?: DependencyCollection;\n    injector?: Injector;\n}\n")),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"collection")," and ",Object(o.b)("inlineCode",{parentName:"p"},"injector")," cannot be both ",Object(o.b)("inlineCode",{parentName:"p"},"undefined"),"."),Object(o.b)("h3",{id:"provide"},"Provide"),Object(o.b)("p",null,"An decorator that could be used on a React class component to provide a injection context on that component."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),"export declare function Provide(\n  items: DependencyItem<any>[]\n): (target: any) => any\n")),Object(o.b)("h3",{id:"inject"},Object(o.b)("inlineCode",{parentName:"h3"},"Inject")),Object(o.b)("p",null,"Returns decorator that could be used on a property of a React class component to inject a dependency"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),"export declare function Inject<T>(\n  id: Identifier<T> | Ctor<T>,\n  optional?: boolean\n): (target: any, propName: string, _originDescriptor?: any) => any\n")),Object(o.b)("h3",{id:"usecollection"},Object(o.b)("inlineCode",{parentName:"h3"},"useCollection")),Object(o.b)("p",null,"When providing dependencies in a functional component, it would be expensive (not to mention logic incorrectness) to recreate dependencies."),Object(o.b)("p",null,"This API is actually a memo to return the same ",Object(o.b)("inlineCode",{parentName:"p"},"DependencyCollection")," in a component."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),"export declare function useCollection(\n  entries?: DependencyItem<any>[]\n): DependencyCollection\n")),Object(o.b)("h3",{id:"usedependency"},Object(o.b)("inlineCode",{parentName:"h3"},"useDependency")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),"export declare function useDependency<T>(\n  key: DependencyKey<T>,\n  optional?: boolean\n): T | null\n")),Object(o.b)("h2",{id:"rxjs"},"RxJS"),Object(o.b)("h3",{id:"usedependencyvalue"},Object(o.b)("inlineCode",{parentName:"h3"},"useDependencyValue")),Object(o.b)("p",null,"Unwrap an observable value, return it to the component for rendering, and trigger re-render when value changes"),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"IMPORTANT"),". Parent and child components should not subscribe to the same observable, otherwise unnecessary re-render would be triggered. Instead, the top-most component should subscribe and pass value of the observable to its offspring, by props or context."),Object(o.b)("p",null,"If you have to do that, consider using ",Object(o.b)("inlineCode",{parentName:"p"},"useDependencyContext")," and ",Object(o.b)("inlineCode",{parentName:"p"},"useDependencyContextValue")," instead."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),"export declare function useDependencyValue<T>(\n  depValue$: Observable<T>,\n  defaultValue?: T\n): T | undefined\n")),Object(o.b)("h3",{id:"usedependencycontext--usedependencycontextvalue"},Object(o.b)("inlineCode",{parentName:"h3"},"useDependencyContext")," & ",Object(o.b)("inlineCode",{parentName:"h3"},"useDependencyContextValue")),Object(o.b)("p",null,"Subscribe to an observable value from a service, creating a context for it so its child component won't have to subscribe again and cause unnecessary."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),"export declare function useDependencyContext<T>(\n  depValue$: Observable<T>,\n  defaultValue?: T\n): {\n  Provider: (props: {\n    initialState?: T | undefined\n    children: React.ReactNode\n  }) => JSX.Element\n  value: T | undefined\n}\n\nexport declare function useDependencyContextValue<T>(\n  depValue$: Observable<T>\n): T | undefined\n")))}void 0!==b&&b&&b===Object(b)&&Object.isExtensible(b)&&!b.hasOwnProperty("__filemeta")&&Object.defineProperty(b,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"src/api.mdx"}}),b.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-api-mdx-26b9341dc097cf98a7f0.js.map